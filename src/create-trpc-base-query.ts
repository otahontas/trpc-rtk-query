import { type BaseQueryFn } from "@reduxjs/toolkit/query/react";
import {
  TRPCClientError,
  type TRPCRequestOptions,
  getUntypedClient,
} from "@trpc/client";
import {
  type AnyProcedure,
  type AnyRouter,
  TRPCError,
  type inferProcedureOutput,
} from "@trpc/server";
import { getHTTPStatusCodeFromError } from "@trpc/server/http";

import { type TRPCClientOptions } from "./trpc-client-options.js";

/**
 * Helper type to get the record from either a router or a record type.
 * @internal
 **/
type GetRecord<T> = T extends AnyRouter ? T["_def"]["record"] : T;

/**
 * Recursively extracts all procedure outputs from a router's record and creates a union type.
 * This allows the base query result type to represent all possible return values.
 * Handles both router objects and record objects.
 * @internal
 **/
type ExtractProcedureOutputsFromRecord<MaybeRouterOrRecord> = {
  [K in keyof GetRecord<MaybeRouterOrRecord>]: GetRecord<MaybeRouterOrRecord>[K] extends AnyProcedure
    ? inferProcedureOutput<GetRecord<MaybeRouterOrRecord>[K]>
    : GetRecord<MaybeRouterOrRecord>[K] extends AnyRouter
      ? ExtractProcedureOutputsFromRecord<GetRecord<MaybeRouterOrRecord>[K]>
      : never;
}[keyof GetRecord<MaybeRouterOrRecord>];

/**
 * Utility type that extracts all possible output types from all procedures in a tRPC router.
 * Returns a union type of all possible procedure outputs.
 * @internal
 **/
type AllProcedureOutputs<TRouter extends AnyRouter> =
  ExtractProcedureOutputsFromRecord<TRouter>;

/**
 * Errors baseQuery can return. Follows the conventions of RTK query's fetchBaseQuery
 **/
type TRPCBaseQueryError =
  | {
      /**
       * * `"TRPC_CLIENT_ERROR"`:
       *   An error that happened on trpc client. Original error is stringified in error
       *   attribute.
       **/
      data?: undefined;
      error: string;
      message: string;
      name: string;
      status: "TRPC_CLIENT_ERROR";
    }
  | {
      /**
       * * `"TRPC_ERROR"`:
       *   An error that was returned by trpc backend. Original error is stringified in
       *   error attribute.
       **/
      data?: undefined;
      error: string;
      message: string;
      name: string;
      status: "TRPC_ERROR";
      statusCode: number;
    }
  | {
      /**
       * * `"UNKNOWN_ERROR"`:
       *   A unknown error type that captures error not wrapped by trpc. Original error
       *   is stringified in error attribute
       **/
      data?: unknown;
      error: string;
      status: "UNKNOWN_ERROR";
    };

/**
 * Typings for trpc specific base query, used by new apis generated by this library.
 * Now properly typed as a union of all possible procedure outputs from the router.
 **/
export type TRPCBaseQuery<TRouter extends AnyRouter = AnyRouter> = BaseQueryFn<
  // Arguments for baseQuery. Should be used when injecting endpoints
  {
    procedureArguments: unknown;
    procedurePath: string;
    procedureType: "mutation" | "query";
  },
  // Result type from backend - union of all possible procedure outputs
  AllProcedureOutputs<TRouter>,
  // Typed errors
  TRPCBaseQueryError,
  // Allow request options (e.g context and signal) to be passed in via extra options
  TRPCRequestOptions,
  // No meta is returned
  never
>;

/**
 * Creates a base query that uses trpc client under the hood.
 * Returns a properly typed base query with result types inferred from the router.
 **/
export const createTRPCBaseQuery =
  <TRouter extends AnyRouter>(
    TRPCClientOptions: TRPCClientOptions<TRouter>,
  ): TRPCBaseQuery<TRouter> =>
  async (baseQueryArguments, baseQueryApi, extraOptions) => {
    const { procedureArguments, procedurePath, procedureType } = baseQueryArguments;

    // Resolve client either directly or via getClient func
    let client;
    if ("client" in TRPCClientOptions) {
      client = getUntypedClient(TRPCClientOptions.client);
    } else if ("getClient" in TRPCClientOptions) {
      client = getUntypedClient(await TRPCClientOptions.getClient(baseQueryApi));
    } else {
      throw new Error("No client or getClient specified in options!");
    }

    try {
      return {
        data: await client[procedureType](
          procedurePath,
          procedureArguments,
          extraOptions,
        ),
      };
    } catch (error) {
      let properlyShapedError: {
        error: TRPCBaseQueryError;
      };
      if (error instanceof TRPCClientError) {
        properlyShapedError = {
          error: {
            error: String(error),
            message: error.message,
            name: error.name,
            status: "TRPC_CLIENT_ERROR",
          },
        };
      } else if (error instanceof TRPCError) {
        properlyShapedError = {
          error: {
            error: String(error),
            message: error.message,
            name: error.name,
            status: "TRPC_ERROR",
            statusCode: getHTTPStatusCodeFromError(error),
          },
        };
      } else {
        properlyShapedError = {
          error: {
            error: String(error),
            status: "UNKNOWN_ERROR",
          },
        };
      }
      return properlyShapedError;
    }
  };
